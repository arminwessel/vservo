#!/usr/bin/env python
"""
Image Based Visual Servoing
"""

from attr import has
import rospy
import numpy as np
from geometry_msgs.msg import Twist, Pose
from vservo.msg import  Point2DArray
import utils

class IBVSController():
    """
    Image Based Visual Servo Controller
    """

    def __init__(self) -> None:
        """
        Constructor
        """
        self._pub = rospy.Publisher("cmd_vel", Twist, queue_size=1) # create publisher
        self._sub = rospy.Subscriber("ibvs_features", Point2DArray, self.feature_update_received) # create subscriber
        self._sub2 = rospy.Subscriber("estimated_pose", Pose, self.update_pose) # create subscriber
        

        _camera_matrix_dict= rospy.get_param("camera_matrix")
        _camera_matrix = np.array(_camera_matrix_dict['data'])
        self.camera_matrix = np.reshape(_camera_matrix, (_camera_matrix_dict['rows'], _camera_matrix_dict['cols']))
        
        _target_str = rospy.get_param("target")
        _target = np.reshape(np.fromstring(_target_str, dtype=int, sep=','),(4,2))
        self.target=utils.conv_nparray_2_Point2DArray(utils.conv_norm_2_pix(_target, self.camera_matrix))

        _target_depth_str = rospy.get_param("target_depth")
        _target_depth = float(_target_depth_str)
        self.target_depth=_target_depth

        self.current_features = None

        self.pose = Pose()
        self.pose.position.z = _target_depth # initialize Z with target depth 

        _lambda_c_str = rospy.get_param("lambda_c")
        _lambda_c = float(_lambda_c_str)
        self.lambda_c=_lambda_c

        

    def calc_error(self) -> np.array:
        """
        Calculate error in pixel coordinates, publish current error
        """
        if (not hasattr(self.current_features,'points')) or (not hasattr(self.target, 'points')):
            return np.zeros((4,2)) # return zero error if target or features are not defined
        if len(self.current_features.points) == 0:
            return np.zeros((4,2)) # return zero error if target or features are not defined
        _array_current = utils.conv_Point2DArray_2_nparray(self.current_features)
        _array_target = utils.conv_Point2DArray_2_nparray(self.target)
        error = _array_target-_array_current
        return error


    def update_pose(self, data) -> None:
        """
        Callback function for the estimated pose from aruco_detector
        """
        self.pose = data


    def feature_update_received(self, data) -> None:
        """
        Callback function for new features from aruco_detector
        """
        self.current_features = data 
        

    def get_Z(self) -> float:
        """
        Return depth (distance on optical axis from camera to marker) in case pose estimation is available.
        If no estimate is available return target depth
        """
        if hasattr(self, 'pose'):
            return self.pose.position.z
        elif hasattr(self, 'target_depth'):
            rospy.logwarn('Assumed target_depth for feature distance Z')
            return self.target_depth           # assume Z to be target depth
        else:
            return None
        
    def update_interaction_matrix(self) -> None:
        """
        Calculate the interaction matrix L with different methods depending on ROS parameter
        """
        L_type=rospy.get_param("L_type")
        if L_type == "TARGET_POINT": 
            # approximate L by using only the normalized image coordinates of the target
            self.L = self.calc_L_matrix_target()
        elif L_type == "CURRENT_POINT": 
            # approximate L by using only the normalized image coordinates of the current feature
            self.L = self.calc_L_matrix_current()
        elif L_type == "MIXED": 
            # approximate L by averaging L of current and target feature
            L1 = self.calc_L_matrix_current()
            L2 = self.calc_L_matrix_target()
            if (np.append(L1,L2,axis=0) == None).any(): # if any of the two matrices L1,L2 contains None, self.L is set to None 
                self.L = None
                return
            self.L = np.multiply(0.5, np.add(L1, L2))
        else:
            rospy.logerr("No method or unknown method specified for calculating L matrix in update_interaction_matrix")


    def calc_L_matrix_current(self) -> np.array:
        # approximate L by using only the normalized image coordinates of the current feature
        if hasattr(self.current_features, 'points'): # check if features are available
            if len(self.current_features.points)>0:
                L = np.zeros([0,6])               # initialize empty matrix with 6 cols
                Z = self.get_Z()
                if Z == None:
                    rospy.logwarn("Distance Z is None")
                    return
                _array_current = utils.conv_Point2DArray_2_nparray(self.current_features)
                normalized_points = utils.conv_pix_2_norm(_array_current, self.camera_matrix)
                for point in normalized_points: 
                    [x, y] = point
                    L = np.append(L,[[-1/Z, 0, x/Z, x*y, -(1+x*x), y], [0, -1/Z, y/Z, 1+y*y, -x*y, -x]],axis=0)
            else: 
                L = np.repeat(None,6).reshape((1,6)) # set L as [[None, None, .. , None]]
            return L
            
        rospy.logwarn("L could not be updated because current features are missing")
    
    def calc_L_matrix_target(self) -> np.array:
        # approximate L by using only the normalized image coordinates of the target feature
        if hasattr(self.target, 'points'): # check if features are available
            if len(self.target.points)>0:
                L = np.zeros([0,6])               # initialize empty matrix with 6 cols
                Z = self.get_Z()
                if Z == None:
                    rospy.logwarn("Distance Z is None")
                    return
                _array_target = utils.conv_Point2DArray_2_nparray(self.target)
                normalized_points = utils.conv_pix_2_norm(_array_target, self.camera_matrix)
                for point in normalized_points: 
                    [x, y] = point
                    L = np.append(L,[[-1/Z, 0, x/Z, x*y, -(1+x*x), y], [0, -1/Z, y/Z, 1+y*y, -x*y, -x]],axis=0)
            else: 
                L = np.repeat(None,6).reshape((1,6)) # set L as [[None, None, .. , None]]
            return L
            
        rospy.logwarn("L could not be updated because target features are missing")
        


    def calc_velocities(self) -> Twist:
        """
        invert L_hat (MP Pseudoinverse) and calculate joint velocities
        """
        velocity_cmd = Twist()                      # initialize empty Twist message

        self.update_interaction_matrix()

        if np.array(self.L == None).any(): # If no interaction matrix is defined, set command velocity to all zeros
            print(self.L)
            _vel=np.zeros(6)
            rospy.logdebug("Interaction Matrix contains None, cmd_vel set to zero")
        else:
            self.L_inv = np.linalg.pinv(self.L)

            _f_x = self.camera_matrix[0,0]
            _f_y = self.camera_matrix[1,1]

            _e = self.calc_error()     # calculate error in pixel coordinates [[du1, dv1],  [du2, dv2],  [du3, dv3], [du4, dv4]]
            _e = np.divide(_e, np.repeat([[_f_x, _f_y]], 4, axis=0)) # calculate error in normalized image plane
            _e_flat = _e.flatten()                           # flaten error [dx1, dy1, dx2, dy2, dx3, dy3, dx4, dy4]

            _vel = - self.lambda_c * np.dot(self.L_inv, _e_flat) # calculate velocity command vector

        # pack the Twist message
        velocity_cmd.linear.x = _vel[0]
        velocity_cmd.linear.y = _vel[1]
        velocity_cmd.linear.z = _vel[2]
        velocity_cmd.angular.x = _vel[3]
        velocity_cmd.angular.y = _vel[4]
        velocity_cmd.angular.z = _vel[5]

        return velocity_cmd
        


# Main function.
if __name__ == "__main__":
    rospy.init_node('ibvservo_node') # init ROS node named ibvservo_node
    rospy.loginfo('#Node vservo_node running#')
    controller = IBVSController()  # create controller instance
    controller_rate = rospy.Rate(10) # 10hz
    while not rospy.is_shutdown():
        #t0 = rospy.get_time()
        cmd_vel = controller.calc_velocities()
        controller._pub.publish(cmd_vel)   # calculate new velocities and publish the result 
        #t1 = rospy.get_time()
        controller_rate.sleep()
        #t2 = rospy.get_time()
        #print('timeslot usage: {} %'.format(100*(t1-t0)/(t2-t0)))
    