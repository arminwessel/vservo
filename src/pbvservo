#!/usr/bin/env python3
"""
Pose Based Visual Servoing
"""

from attr import has
import rospy
import numpy as np
from geometry_msgs.msg import Twist, Pose
#from vservo.msg import  Point2DArray
from std_msgs.msg import Float32
import utils
from scipy.spatial.transform import Rotation
from pytransform3d import rotations as pr
from pytransform3d import transformations as pt
from pytransform3d.transform_manager import TransformManager

class PBVSController():
    """
    Pose Based Visual Servo Controller
    """

    def __init__(self) -> None:
        """
        Constructor
        """
        self._pub = rospy.Publisher("cmd_vel", Twist, queue_size=1) # create publisher
        self._sub = rospy.Subscriber("estimated_pose", Pose, self.update_pose) # create subscriber
        

        _camera_matrix_dict= rospy.get_param("camera_matrix")
        _camera_matrix = np.array(_camera_matrix_dict['data'])
        self.camera_matrix = np.reshape(_camera_matrix, (_camera_matrix_dict['rows'], _camera_matrix_dict['cols']))
        
        _target_str = rospy.get_param("target")
        self.target = np.reshape(np.fromstring(_target_str, dtype=int, sep=','),(4,2))

        self.current_features = None

        self.pose = Pose()

        _lambda_c_str = rospy.get_param("lambda_c")
        _lambda_c = float(_lambda_c_str)
        self.lambda_c=_lambda_c


        

    def calc_velocities(self) -> Twist:
        """
        Calculate velocities
         - read from parameter server to determine if PBVS1 or PBVS2 should be used
                # PBVS_type=rospy.get_param("PBVS_type")
         - check if all necessary data is available 
                # hasattr and (stuff==None).any()
         - invoke function to calculate velocity based on which methos is to be used
         - pack velocities vector into twist
         - return twist
        """
        PBVS_type=rospy.get_param("PBVS_type")
        if PBVS_type == "PBVS1": 
            # test if all data is given and call function to calculate velocities
            # TODO
            c = self.calc_pbvs_1()

            cmd_vel=Twist()
            cmd_vel.linear.x=c[0]
            cmd_vel.linear.y=c[1]
            cmd_vel.linear.z=c[2]
            cmd_vel.angular.x=c[3]
            cmd_vel.angular.y=c[4]
            cmd_vel.angular.z=c[5]

            return cmd_vel
            
        elif PBVS_type == "PBVS2": 
            # test if all data is given and call function to calculate velocities
            # TODO
            
            c = self.calc_pbvs_2()

            cmd_vel=Twist()
            cmd_vel.linear.x=c[0]
            cmd_vel.linear.y=c[1]
            cmd_vel.linear.z=c[2]
            cmd_vel.angular.x=c[3]
            cmd_vel.angular.y=c[4]
            cmd_vel.angular.z=c[5]

            return cmd_vel
        else:
            rospy.logerr("No method or unknown method specified for PBVS type")


    def update_pose(self, data) -> None:
        """
        Callback function for the estimated pose from aruco_detector
        """
        self.pose = data


        
    def calc_pbvs_1(self) -> np.array:
        """
        Calculate velocities based on poses of the object from current and desired camera position
        """
        # Find position of marker described in desired camera coordinate system

        # get pose from target corner specification
        norm_camera_matrix=np.eye(3) # camera matrix for normalized image plane
        norm_distortion_coefficients = np.zeros(5).reshape((1,5)) # ideal camera - all zero distortions
        pose_desired = utils.get_pose_from_coordinates(coordinates=self.target, 
                    camera_matrix=norm_camera_matrix, camera_distortion=norm_distortion_coefficients) 
        _pos = pose_desired.position # unpack t from pose
        t_0_desired = np.array([_pos.x, _pos.y, _pos.z]) 
        
        # Find position of marker described in current camera coordinate system
        _pos = self.pose.position # unpack t from current estimated camera pose
        t_0_current = np.array([_pos.x, _pos.y, _pos.z])

        _quat = self.pose.orientation # unpack theta_u from pose
        _r = Rotation.from_quat(np.array([_quat.x, _quat.y, _quat.z, _quat.w])) # Rotation object from SciPy
        theta_u = Rotation.as_rotvec(_r) # use rotation object to convert to angle axis representation

        # implement control law
        v_c = -self.lambda_c * (np.subtract(t_0_desired, t_0_current)+np.cross(t_0_current, theta_u))
        w_c = -self.lambda_c * (theta_u)

        return np.append(v_c, w_c)


    def calc_pbvs_2(self) -> np.array:
        """
        Calculate velocities based on pose of current camera in reference desired camera position
        """
        #  # get pose from target corner specification
        # norm_camera_matrix=np.eye(3) # camera matrix for normalized image plane
        # norm_distortion_coefficients = np.zeros(5).reshape((1,5)) # ideal camera - all zero distortions
        # pose_desired = utils.get_pose_from_coordinates(coordinates=self.target, 
        #             camera_matrix=norm_camera_matrix, camera_distortion=norm_distortion_coefficients) 

        ####################################################################
        pose_desired = Pose()
        pose_desired.position.x = 0
        pose_desired.position.y = 0
        pose_desired.position.z = 1

        [pose_desired.orientation.x, 
        pose_desired.orientation.y, 
        pose_desired.orientation.z, 
        pose_desired.orientation.w] = pr.quaternion_from_axis_angle([1,0,0,0.0*np.pi])


        _pos = pose_desired.position
        t_0_desired = np.array([_pos.x, _pos.y, _pos.z]) 
        

        _pos = self.pose.position
        t_0_current = np.array([_pos.x, _pos.y, _pos.z])

        _quat = self.pose.orientation
        try:
            _r = Rotation.from_quat(np.array([_quat.x, _quat.y, _quat.z, _quat.w])) # Rotation object from SciPy
            theta_u = Rotation.as_rotvec(_r)
        except:
            print('error in scipy')
            theta_u = np.array([0,0,0])

        v_c = -self.lambda_c * (np.subtract(t_0_desired, t_0_current)+np.cross(t_0_current, theta_u))
        w_c = -self.lambda_c * (theta_u)

        return np.append(v_c, w_c)




# Main function.
if __name__ == "__main__":
    rospy.init_node('pbvservo_node') # init ROS node named ibvservo_node
    rospy.loginfo('#Node pbvservo_node running#')

    controller = PBVSController()  # create controller instance

    controller_rate = rospy.Rate(100) # 10hz
    pub_timeslot = rospy.Publisher("timeslot_usage", Float32, queue_size=1) # create publisher
    while not rospy.is_shutdown():
        t0 = rospy.get_time()
        cmd_vel = controller.calc_velocities()
        controller._pub.publish(cmd_vel)   # calculate new velocities and publish the result 
        t1 = rospy.get_time()
        controller_rate.sleep()
        t2 = rospy.get_time()
        #print('timeslot usage: {} %'.format(100*(t1-t0)/(t2-t0)))
        pub_timeslot.publish(100*(t1-t0)/(t2-t0))
    